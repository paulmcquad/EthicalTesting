JumpJumpJump Crackme
https://crackmes.one/crackme/5c1a939633c5d41e58e005d1

This crackme loops through a string, adds all the ascii characters including
null byte, and compares against a hard coded value of 0x3E8.

I used the ascii value n 9 times.
(0x6E * 9) + 0xA = 0x3E8

The flag is generated using the strcat_str() function, which writes the flag to a global
char array. The function starts with an '!' value, and then uses that character to generate the next
character in the array. It does this by taking the value, adding it by the value, and adding 1 to that value.
The third value is generated by the second, and the fourth is generated by the third, and so on.


============================================================
[user@comp ~/crackmes.one/jumpjumpjump]# ./rev03 
enter the magic string
nnnnnnnnn
flag is flag{!#&*/5<DMW}
[user@comp ~/crackmes.one/jumpjumpjump]# 
============================================================



Source Code
==================================================================================
#include <stdio.h>
#include <string.h>

char flag[10];
char inputString[64];
char *part1 = "flag is flag{";
char *part2 = "}";

char *strcat_str() {
	flag[0] = '!';
	int counter = 1;
	while (counter < 10) {
		flag[counter] = flag[counter-1] + counter + 1;
		counter++;
	}	
	return flag;
}
int main() {
	int asciiSum = 0;
	puts("enter the magic string");
	fgets(inputString, 64, stdin);
	if (strlen(inputString) >= 11) {
		puts("too long...sorry no flag for you!!!");
	} else {
		int counter = 0;
		while (counter < strlen(inputString)) {
			asciiSum += inputString[counter];
			counter++;
		}
		if (asciiSum == 1000) {
			strcat_str();
			printf(part1);
			int count = 0;
			while (count < 10) {
				putchar(flag[count]);
				count++;
			}
			puts(part2);
		} else {
			puts("wrong string\nNo flag for you.");
		}
	}
}
==================================================================================



Assembly


00000000000011ca <main>:
    11ca:	55                   	push   rbp
    11cb:	48 89 e5             	mov    rbp,rsp
    11ce:	53                   	push   rbx

    11cf:	48 81 ec 88 00 00 00 	sub    rsp,0x88
    11d6:	c7 45 ec 00 00 00 00 	mov    DWORD PTR [rbp-0x14],0x0		; init ascii sum integer var

# Print welcome message
    11dd:	48 8d 3d 24 0e 00 00 	lea    rdi,[rip+0xe24]        		; "enter the magic string"
    11e4:	e8 57 fe ff ff       	call   1040 <puts@plt>			; print "enter the magic string"

# Get string input
    11e9:	48 8b 15 60 2e 00 00 	mov    rdx,QWORD PTR [rip+0x2e60]       ; stdin FILE *stream
    11f0:	48 8d 85 70 ff ff ff 	lea    rax,[rbp-0x90]			; string buffer
    11f7:	be 64 00 00 00       	mov    esi,0x64				; max characters in string
    11fc:	48 89 c7             	mov    rdi,rax				; move string buffer to rdi
    11ff:	e8 6c fe ff ff       	call   1070 <fgets@plt>			; call fgets

# Get length of string
    1204:	48 8d 85 70 ff ff ff 	lea    rax,[rbp-0x90]			; move string buffer into rax
    120b:	48 89 c7             	mov    rdi,rax				; move string buffer into rdi
    120e:	e8 3d fe ff ff       	call   1050 <strlen@plt>		; get length of string

# Make sure the length of string is < 11
    1213:	48 83 f8 0b          	cmp    rax,0xb				; is string 11 characters?
    1217:	76 16                	jbe    122f <main+0x65>			; if less than or equal to 11, jump

# Print Error is string is >= 11
    1219:	48 8d 3d 00 0e 00 00 	lea    rdi,[rip+0xe00]        		; "too long...sorry no flag for you!!!"
    1220:	e8 1b fe ff ff       	call   1040 <puts@plt>			; print above string
    1225:	b8 00 00 00 00       	mov    eax,0x0				; ??
    122a:	e9 b3 00 00 00       	jmp    12e2 <main+0x118>		; exit program

# Get Sum of entire string including null byte
    122f:	c7 45 e8 00 00 00 00 	mov    DWORD PTR [rbp-0x18],0x0		; loop counter
    1236:	eb 17                	jmp    124f <main+0x85>			; enter loop

    1238:	8b 45 e8             	mov    eax,DWORD PTR [rbp-0x18]		; load counter to eax
    123b:	48 98                	cdqe   					; extend stuff
    123d:	0f b6 84 05 70 ff ff 	movzx  eax,BYTE PTR [rbp+rax*1-0x90]	; move password[counter] to eax
    1244:	ff 
    1245:	0f be c0             	movsx  eax,al
    1248:	01 45 ec             	add    DWORD PTR [rbp-0x14],eax		; add ascii value to rbp-0x14
    124b:	83 45 e8 01          	add    DWORD PTR [rbp-0x18],0x1		; add 1 to counter
    124f:	8b 45 e8             	mov    eax,DWORD PTR [rbp-0x18]		; put counter into eax
    1252:	48 63 d8             	movsxd rbx,eax				; move counter to rbx
    1255:	48 8d 85 70 ff ff ff 	lea    rax,[rbp-0x90]			; move password string into rax
    125c:	48 89 c7             	mov    rdi,rax				; move string from rax to rdi
    125f:	e8 ec fd ff ff       	call   1050 <strlen@plt>		; get length of password
    1264:	48 39 c3             	cmp    rbx,rax				; is length < counter?
    1267:	72 cf                	jb     1238 <main+0x6e>			; jump if so


# Is the sum equal to 0x3e8? Exit with error message if not
    1269:	81 7d ec e8 03 00 00 	cmp    DWORD PTR [rbp-0x14],0x3e8	; is the sum of ascii 0x3e8?
    1270:	75 5f                	jne    12d1 <main+0x107>		; jump if not equal


# Print flag
# Loop 9 times across input string, 
    1272:	b8 00 00 00 00       	mov    eax,0x0
    1277:	e8 f9 fe ff ff       	call   1175 <strcat_str>		; generate flag and put pointer into rax
    127c:	48 89 45 e0          	mov    QWORD PTR [rbp-0x20],rax		; put pointer to flag into stack
    1280:	48 8d 3d bd 0d 00 00 	lea    rdi,[rip+0xdbd]        		; load "flag is flag{" to rdi
    1287:	b8 00 00 00 00       	mov    eax,0x0				; ??
    128c:	e8 cf fd ff ff       	call   1060 <printf@plt>		; print "flag is flag{"

    1291:	c7 45 e8 00 00 00 00 	mov    DWORD PTR [rbp-0x18],0x0		; make counter 0
    1298:	eb 1e                	jmp    12b8 <main+0xee>			; jump into loop

    129a:	8b 45 e8             	mov    eax,DWORD PTR [rbp-0x18]		; put counter into eax
    129d:	48 63 d0             	movsxd rdx,eax				; move counter into rdx
    12a0:	48 8b 45 e0          	mov    rax,QWORD PTR [rbp-0x20]		; move pointer to flag into rax
    12a4:	48 01 d0             	add    rax,rdx				; increment pointer by counter
    12a7:	0f b6 00             	movzx  eax,BYTE PTR [rax]		; move value pointed to into eax
    12aa:	0f be c0             	movsx  eax,al				; focus in on char
    12ad:	89 c7                	mov    edi,eax				; put the char into edi
    12af:	e8 7c fd ff ff       	call   1030 <putchar@plt>		; print the char
    12b4:	83 45 e8 01          	add    DWORD PTR [rbp-0x18],0x1		; add 1 to the counter
    12b8:	83 7d e8 09          	cmp    DWORD PTR [rbp-0x18],0x9		; compare counter to 9
    12bc:	7e dc                	jle    129a <main+0xd0>			; is counter < 10?

    12be:	48 8d 3d 8d 0d 00 00 	lea    rdi,[rip+0xd8d]        		; load "}" to rdi
    12c5:	e8 76 fd ff ff       	call   1040 <puts@plt>			; print "}"
    12ca:	b8 00 00 00 00       	mov    eax,0x0
    12cf:	eb 11                	jmp    12e2 <main+0x118>		; exit program



    12d1:	48 8d 3d 7c 0d 00 00 	lea    rdi,[rip+0xd7c]        		; "wrong string\nNo flag for you."
    12d8:	e8 63 fd ff ff       	call   1040 <puts@plt>			; print above
    12dd:	b8 00 00 00 00       	mov    eax,0x0				; return int

    12e2:	48 81 c4 88 00 00 00 	add    rsp,0x88
    12e9:	5b                   	pop    rbx
    12ea:	5d                   	pop    rbp
    12eb:	c3                   	ret    
    12ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]






==============
= strcat_str =
==============

   0x0000555555555175 <+0>:	push   rbp
   0x0000555555555176 <+1>:	mov    rbp,rsp

# 
   0x0000555555555179 <+4>:	mov    BYTE PTR [rip+0x2ee0],0x21        	; move ! into buffer
   0x0000555555555180 <+11>:	mov    DWORD PTR [rbp-0x4],0x1			; move counter into stack
   0x0000555555555187 <+18>:	jmp    0x5555555551bb <strcat_str+70>		; jump into loop

## Loop Begin

   0x0000555555555189 <+20>:	mov    eax,DWORD PTR [rbp-0x4]			; move counter into eax
   0x000055555555518c <+23>:	sub    eax,0x1					; subtract counter by 1
   0x000055555555518f <+26>:	cdqe   						; turn dword eax to qword rax
   0x0000555555555191 <+28>:	lea    rdx,[rip+0x2ec8]       			; move pointer to buffer into rdx
   0x0000555555555198 <+35>:	movzx  eax,BYTE PTR [rax+rdx*1]			; put buffer[counter] into eax
   0x000055555555519c <+39>:	mov    edx,eax					; move buffer[counter] into edx
   0x000055555555519e <+41>:	mov    eax,DWORD PTR [rbp-0x4]			; put counter into eax
   0x00005555555551a1 <+44>:	add    eax,edx					; eax = buffer[i] + i
   0x00005555555551a3 <+46>:	add    eax,0x1					; eax = eax + 1
   0x00005555555551a6 <+49>:	mov    ecx,eax					; move result ascii into ecx
   0x00005555555551a8 <+51>:	mov    eax,DWORD PTR [rbp-0x4]			; move counter into eax
   0x00005555555551ab <+54>:	cdqe   						; subtract counter by 1
   0x00005555555551ad <+56>:	lea    rdx,[rip+0x2eac]				; move pointer of buffer into rdx
   0x00005555555551b4 <+63>:	mov    BYTE PTR [rax+rdx*1],cl			; move altered ascii into buffer
   0x00005555555551b7 <+66>:	add    DWORD PTR [rbp-0x4],0x1			; add 1 to counter in stack
   0x00005555555551bb <+70>:	cmp    DWORD PTR [rbp-0x4],0x9			; is the loop counter < 9?
   0x00005555555551bf <+74>:	jle    0x555555555189 <strcat_str+20>		; if so, jumpp to beginning of loop

## Loop End

   0x00005555555551c1 <+76>:	lea    rax,[rip+0x2e98]        # 0x555555558060 <f.2605>
   0x00005555555551c8 <+83>:	pop    rbp
   0x00005555555551c9 <+84>:	ret    





